using System;
using System.Collections.Concurrent;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Text.RegularExpressions;

namespace Invio.Extensions.Reflection {

    /// <summary>
    ///   Extensions on the <see cref="PropertyInfo" /> type that make it possible
    ///   to determine if a field storing that property's value was automatically
    ///   generated by the compiler due to the developer's use of "auto-implemented
    ///   property" syntax.
    /// </summary>
    public static class AutoImplementedPropertyInfoExtensions {

        private static Regex isBackingFieldName { get; }
        private static ConcurrentDictionary<PropertyInfo, bool> isAutoImplementedCache { get; }

        static AutoImplementedPropertyInfoExtensions() {
            isBackingFieldName = new Regex(@"^<(?<PropertyName>\w+)>k__BackingField$");
            isAutoImplementedCache = new ConcurrentDictionary<PropertyInfo, bool>();
        }

        /// <summary>
        ///   This method determines whether or not the accessors for a property
        ///   is an "auto-implemented" property. These are properties that use syntax
        ///   such as <code>{ get; }</code> or <code>{ protected set; }</code> which
        ///   results in a compiler-generated field that stores that property's value.
        /// </summary>
        /// <remarks>
        ///   <para>
        ///     With its current implementation, this method is not fool-proof. It is
        ///     possible to deceive this method by creating methods and fields that
        ///     follow the naming conventions employed by the C# compiler to generate
        ///     the backing implementations of auto-properties, then annotating those
        ///     with the <see cref="CompilerGeneratedAttribute" />. However, this is
        ///     pretty unlikely. The only realistic scenario of this occurring is due
        ///     to developer intentionally trying to deceive consumers of this method.
        ///   </para>
        ///   <para>
        ///     For the sake of efficiency, this implementation caches its results.
        ///     The initial call is somewhat expensive as it has to potentially parse
        ///     large amounts of content in the reflection namespace, but repeat
        ///     invocations will cost only a cache hit to a concurrent dictionary.
        ///   </para>
        /// </remarks>
        /// <param name="property">
        ///   The <see cref="PropertyInfo" /> instance the caller wants to check
        ///   to see if it is an "auto-implemented" property.
        /// </param>
        /// <exception cref="ArgumentNullException">
        ///   Thrown when <paramref name="property" /> is null.
        /// </exception>
        /// <returns>
        ///   This returns <c>true</c> if the method is an "auto-implemented" property.
        ///   Otherwise, this method returns <c>false</c>
        /// </returns>
        public static bool IsAutoImplemented(this PropertyInfo property) {
            if (property == null) {
                throw new ArgumentNullException(nameof(property));
            }

            return isAutoImplementedCache.GetOrAdd(property, IsAutoImplementedImpl);
        }

        private static bool IsAutoImplementedImpl(PropertyInfo property) {
            var getMethodInfo = property.GetGetMethod(nonPublic: true);

            if (getMethodInfo == null) {
                return false;
            }

            if (!IsCompilerGenerated(getMethodInfo)) {
                return false;
            }

            return HasBackingFieldInfo(property);
        }

        private static bool HasBackingFieldInfo(PropertyInfo property) {
            const BindingFlags flags =
                BindingFlags.Instance | BindingFlags.Static | BindingFlags.NonPublic;

            return
                property
                    .DeclaringType
                    .GetFields(flags)
                    .Where(field => IsMatchingFieldName(property, field))
                    .Where(IsCompilerGenerated)
                    .Any();
        }

        private static bool IsCompilerGenerated(MemberInfo memberInfo) {
            return
                memberInfo
                    .GetCustomAttributes(typeof(CompilerGeneratedAttribute), inherit: true)
                    .Any();
        }

        private static bool IsMatchingFieldName(PropertyInfo property, FieldInfo field) {
            var match = isBackingFieldName.Match(field.Name);

            return match.Success
                && match.Groups["PropertyName"].Value == property.Name;
        }

    }

}
